version: '3.8'

services:
# Dev containers
  portainer:
    # Container management
    image: portainer/portainer-ce:2.16.2
    container_name: portainer
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./portainer-data:/data
    ports:
      - ${PORTAINER_PORT}:${PORTAINER_PORT}
    profiles: ['dev', 'test']

  database:
    container_name: postgres
    image: postgres:12.0-alpine
    volumes:
      - postgres_data:${POSTGRES_DATA_DIR}
    ports:
      - ${DATABASE_PORT}:${DATABASE_PORT}
    env_file:
      - ./.database.env
    healthcheck:
      test: pg_isready -U ${SQL_USER} -d ${SQL_DATABASE}
      interval: 1s
      retries: 30
      timeout: 1s
    logging:
      options:
        max-size: 100m
    profiles: ['dev', 'test']

  logging-db:
    # Database for mainapp logging
    container_name: mongodb
    image: mongo:4.0.4
    ports:
      - ${LOGGING_DB_PORT}:${LOGGING_DB_PORT}
    volumes:
      - mongodb_data:${MONGODB_DATA_DIR}
    env_file:
      - ./.logging-db.env
    healthcheck:
      test: mongo --eval 'db.runCommand("ping").ok' localhost:${LOGGING_DB_PORT} --quiet
      interval: 5s
      retries: 10
      start_period: 15s
      timeout: 10s
    logging:
      options:
        max-size: 50m
    profiles: ['dev', 'test']

  message-broker:
    container_name: redis
    image: redis:6.2.7-alpine
    ports:
      - ${MESSAGE_BROKER_PORT}:${MESSAGE_BROKER_PORT}
    logging:
      options:
        max-size: 50m
    profiles: ['dev', 'test']

  log-cli:
    # Log CLI tool for Mongodb
    container_name: log-cli
    tty: true
    build:
      context: ./racks_log_cli
      dockerfile: Dockerfile
    env_file:
      - ./racks_log_cli/.log-cli.env
    logging:
      options:
        max-size: 50m
    depends_on:
      - logging-db
    profiles: ['dev', 'test']

  backend:
    &django
    container_name: django
    domainname: backend
    entrypoint: /home/app/web/entrypoint_main.sh
    build:
      context: ./
      dockerfile: Dockerfile
    healthcheck:
      test: curl -f http://0.0.0.0:${BACKEND_PORT}/api/v1 || exit 1
      interval: 5s
      retries: 10
      start_period: 15s
      timeout: 10s
    ports:
      - ${BACKEND_PORT}:${BACKEND_PORT}
    logging:
      options:
        max-size: 100m
    volumes:
      - static_volume:${STATIC_DIR}
    env_file:
      - ./.env
      - ./.backend.env
      - ./.database.env
      - ./.logging-db.env
      - ./e2e_tests/.test-runner.env
    profiles: ['dev', 'test']
    depends_on:
      database:
        condition: service_healthy
      logging-db:
        condition: service_healthy

  # Containers for linter, type check and unit tests
  django-linter:
    <<: *django
    container_name: django-linter
    entrypoint: /home/app/web/entrypoint_linter.sh
    volumes:
      - log_volume:${LOGS_DIR}
    ports:
      - ${BACKEND_PORT_RESERVE}:${BACKEND_PORT_RESERVE}

  django-unit-tests:
    <<: *django
    container_name: django-unit-tests
    entrypoint: /home/app/web/entrypoint_unit.sh
    volumes:
      - log_volume:${LOGS_DIR}
    ports:
      - ${BACKEND_PORT_RESERVE2}:${BACKEND_PORT_RESERVE2}

  django-typing:
    <<: *django
    container_name: django-typing
    entrypoint: /home/app/web/entrypoint_typing.sh
    volumes:
      - log_volume:${LOGS_DIR}
    ports:
      - ${BACKEND_PORT_RESERVE3}:${BACKEND_PORT_RESERVE3}

  worker:
    container_name: celery-worker
    build: .
    entrypoint: celery -A ${APP_NAME} worker -l INFO
    volumes:
      - backups_volume:${BACKUP_DIR}
      - static_volume:${STATIC_DIR}
    env_file:
      - ./.env
      - ./.backend.env
      - ./.database.env
      - ./.logging-db.env
    logging:
      options:
        max-size: 50m
    profiles: ['dev', 'test']
    depends_on:
      backend:
        condition: service_healthy
      message-broker:
        condition: service_started
  
  cron:
    # Celery cron for data backups
    container_name: celery-beat
    build: .
    entrypoint: celery -A ${APP_NAME} beat -l INFO --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - backups_volume:${BACKUP_DIR}
      - static_volume:${STATIC_DIR}
    env_file:
      - ./.env
      - ./.backend.env
      - ./.database.env
      - ./.logging-db.env
    logging:
      options:
        max-size: 50m
    profiles: ['dev', 'test']
    depends_on:
      backend:
        condition: service_healthy
      message-broker:
        condition: service_started
      worker:
        condition: service_started

  frontend:
    container_name: vue
    domainname: frontend
    command: npm run serve
    build:
      context: ./racks_frontend
      dockerfile: Dockerfile
    healthcheck:
      test: curl -f http://0.0.0.0:${FRONTEND_PORT} || exit 1
      interval: 5s
      retries: 10
      start_period: 15s
      timeout: 10s
    volumes:
      - vue_dist:${VUE_DIST_DIR}
    logging:
      options:
        max-size: 100m
    ports:
      - ${FRONTEND_PORT}:${FRONTEND_PORT}
    profiles: ['dev', 'test']
    depends_on:
      - backend
      
  web-server:
    container_name: nginx
    build: ./nginx
    ports:
      - ${WEB_SERVER_PORT}:${WEB_SERVER_PORT}
    logging:
      options:
        max-size: 50m
    volumes:
      - static_volume:${STATIC_DIR}
      - vue_dist:${VUE_DIST_DIR}
    profiles: ['dev', 'test']
    depends_on:
      - backend
      - frontend

  flower:
    # Celery monitoring
    container_name: flower
    image: mher/flower:1.2.0
    command: celery flower --persisten=True
    ports:
      - ${FLOWER_PORT}:${FLOWER_PORT}
    volumes:
      - flower_data:${FLOWER_DATA_DIR}
    env_file:
      - ./.flower.env
    depends_on:
      - frontend
      - message-broker
      - worker
      - cron
    profiles: ['dev', 'test']

# E2E testing containers
  frontend-testing:
    # Frontend for seleium grid
    container_name: vue-testing
    domainname: frontend-testing
    command: npm run serve -- --port ${FRONTEND_TESTING_PORT}
    build:
      context: ./racks_frontend
      dockerfile: Dockerfile_test
    healthcheck:
      test: curl -f http://0.0.0.0:${FRONTEND_TESTING_PORT} || exit 1
      interval: 5s
      retries: 10
      start_period: 15s
      timeout: 10s
    volumes:
      - vue_dist:${VUE_DIST_DIR}
    ports:
      - ${FRONTEND_TESTING_PORT}:${FRONTEND_TESTING_PORT}
    logging:
      options:
        max-size: 100m
    profiles: ['test']
    depends_on:
      - backend

  selenium:
    container_name: chrome
    image: selenium/standalone-chrome
    extra_hosts:
      - host.docker.internal:host-gateway
    env_file:
      - ./e2e_tests/.selenium.env
    volumes:
      - /dev/shm:/dev/shm
    ports:
      - ${SELENIUM_PORT}:${SELENIUM_PORT}
    logging:
      options:
        max-size: 50m
    profiles: ['test']
    depends_on:
      - frontend-testing
      - backend

  test-runner:
    # E2E tests
    container_name: e2e-tests
    build:
      context: ./e2e_tests
      dockerfile: Dockerfile
    command: python e2e_tests.py
    env_file:
      - ./.env
      - ./e2e_tests/.test-runner.env
    ports:
      - 4445:4445
    logging:
      options:
        max-size: 100m
    volumes:
      - test_results:${TEST_RESULTS_PATH}
    profiles: ['test']
    depends_on:
      backend:
        condition: service_healthy
      frontend-testing:
        condition: service_healthy
      selenium:
        condition: service_started


volumes:
  postgres_data:
  mongodb_data:
  flower_data:
  static_volume:
  log_volume: # log files for mypy, flake8, unittest
  backups_volume:
  test_results:
  vue_dist:
  